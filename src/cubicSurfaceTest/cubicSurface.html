<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Cubic Surfaces – Single File</title>

  <!-- KaTeX -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css"/>
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.js"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/contrib/copy-tex.min.css"/>
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/contrib/copy-tex.min.js"></script>

  <!-- Bootstrap (optional) -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css"/>
  <style>
    body { background:#f5f6f8; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, 'Liberation Mono', monospace; }
  </style>
</head>
<body>
<div class="container my-4">
  <div class="row g-3">
    <div class="col-12"><h3 class="mb-2">Cubic Surfaces (Single File)</h3></div>

    <!-- Controls -->
    <div class="col-12">
      <div class="p-3 bg-white rounded shadow-sm mb-3">
        <div class="row g-3 align-items-end">
          <div class="col-12 col-md-3">
            <label class="form-label mb-1">Surface</label>
            <select id="surfaceMode" class="form-select form-select-sm">
              <option value="sphere">Sphere</option>
              <option value="clebsch">Clebsch</option>
              <option value="cayley">Cayley-Kubik</option>
              <option value="monkeySaddle">Monkey Saddle</option>
              <option value="cylinder">Cylinder</option>
              <option value="crosspropeller">Crosspropeller</option>
              <option value="custom">Custom</option>
            </select>
          </div>
          <div class="col-12 col-md-3">
            <label class="form-label mb-1">View</label>
            <select id="viewMode" class="form-select form-select-sm">
              <option value="1">Perspective</option>
              <option value="2">Orthographic</option>
              <option value="3">Stereo (Rot/Cyan)</option>
            </select>
          </div>
          <div class="col-12 col-md-3">
            <div class="form-check mt-4">
              <input class="form-check-input" type="checkbox" id="showBox" checked>
              <label class="form-check-label" for="showBox">show Volumecube</label>
            </div>
          </div>
        </div>
      </div>

      <div id="sliderContainer" class="p-3 bg-white rounded shadow-sm mb-3"></div>

      <div id="formulaBox" class="p-3 bg-white rounded shadow-sm mb-3">
        <div id="formulaText" class="mono" style="font-size:14px;line-height:1.4;">F(x,y,z)=0</div>
      </div>
    </div>

    <!-- Canvas -->
    <div class="col-12">
      <div class="ratio ratio-16x9">
        <canvas id="glCanvas" class="w-100 h-100"></canvas>
      </div>
    </div>
  </div>
</div>

<script type="module">
/* =========================
   1) UI + State (aus deinem Code, ohne iframe)
   ========================= */
const monomials = [
  "x^3","y^3","z^3","x^2y","x^2z","y^2z","yz^2","xy^2","xz^2","xyz",
  "x^2","y^2","z^2","xz","xy","yz","x","y","z","1"
];
const rows = [
  ["x^3","y^3","z^3","x^2y","x^2z","y^2z","yz^2","xy^2","xz^2","xyz"],
  ["x^2","y^2","z^2","xz","xy","yz"],
  ["x","y","z"],
  ["1"]
];
// Defaults: Kugel x^2 + y^2 + z^2 − 1 = 0
const defaults = {"x^3":0,"y^3":0,"z^3":0,"x^2y":0,"x^2z":0,"y^2z":0,"yz^2":0,"xy^2":0,"xz^2":0,"xyz":0,"x^2":1,"y^2":1,"z^2":1,"xz":0,"xy":0,"yz":0,"x":0,"y":0,"z":0,"1":-1};

const PRESETS = {
  sphere:[0,0,0, 0,0,0,0,0,0,0, 1,1,1, 0,0,0, 0,0,0, -1],
  clebsch:[81,81,81, -189,-189,-189,-189,-189,-189,54, -9,-9,-9, 126,126,126, -9,-9,-9, 1],
  cayley:[0,0,0, 0,0,0,0,0,0,1, 0,0,0, 0,0,0, 0,1,1, 1],
  monkeySaddle:[1,0,0, 0,0,0,0,-3,0,0, 0,0,0, 0,0,0, 0,0,-1, 0],
  cylinder:[0,0,0, 0,0,0,0,0,0,0, 1,1,0, 0,0,0, 0,0,0, -1],
  crosspropeller:[0,0,0, 0,0,0,0,0,0,1, 1,0.1,0, 0,0,0, 0,0,0, 0],
  custom:Array(20).fill(0)
};
const latexMono = {"x^3":"x^{3}","y^3":"y^{3}","z^3":"z^{3}","x^2y":"x^{2}y","x^2z":"x^{2}z","y^2z":"y^{2}z","yz^2":"y z^{2}","xy^2":"x y^{2}","xz^2":"x z^{2}","xyz":"x y z","x^2":"x^{2}","y^2":"y^{2}","z^2":"z^{2}","xz":"x z","xy":"x y","yz":"y z","x":"x","y":"y","z":"z","1":"1"};
const NEAR_ZERO = 1e-9;
const inputs=[], sliders=[];
function parseNum(s){ if(typeof s!=='string') s=String(s??''); return parseFloat(s.replace(',','.')); }
const isZero = (n)=>Math.abs(n)<NEAR_ZERO;
function niceNumber(n){ let s=Number(n).toFixed(3).replace(/\.?0+$/,''); if(s==='-0') s='0'; return s; }
function termToTeX(coeff, monoKey){ const abs=Math.abs(coeff); if(monoKey==="1") return niceNumber(abs); const mono=latexMono[monoKey]||monoKey; if(Math.abs(abs-1)<NEAR_ZERO) return mono; return `${niceNumber(abs)}\\,${mono}`; }
function termsPerLineForWidth(px){ if(px<420) return 6; if(px<640) return 8; if(px<900) return 10; if(px<1200) return 12; return 14; }
function buildFormulaTeXWrapped(coeffs, tpl){
  const parts=[]; monomials.forEach((m,i)=>{ const c=Number(coeffs[i]??0); if(isZero(c)) return; parts.push({sign:c<0?"-":"+", body:termToTeX(c,m)}); });
  if(parts.length===0) return `F(x,y,z)=0`;
  const lines=[]; let line=`F(x,y,z) &= `; let count=1;
  line += (parts[0].sign==="+")?`${parts[0].body}`:`- ${parts[0].body}`;
  for(let k=1;k<parts.length;k++){ if(count>=tpl){ lines.push(line); line=`&\\quad `; count=0; } line += (parts[k].sign==="+")?` + ${parts[k].body}`:` - ${parts[k].body}`; count++; }
  line += ` = 0`; lines.push(line);
  return `\\begin{aligned} ${lines.join(' \\\\ ')} \\end{aligned}`;
}
function monoLabelHTML(monoKey){ return katex.renderToString(latexMono[monoKey]||monoKey, {displayMode:false, throwOnError:false}); }
function createSlider(mono){
  const base = Number(defaults[mono] ?? 0);
  const wrap = document.createElement("div");
  wrap.style.cssText="flex:0 0 9%;max-width:9%;display:flex;flex-direction:column;align-items:center;";
  const lab=document.createElement("div"); lab.style.cssText="font-size:10px;font-weight:600;text-align:center;margin-bottom:2px;line-height:1.1;"; lab.innerHTML=monoLabelHTML(mono);
  const num=document.createElement("input"); num.type="number"; num.setAttribute('lang','de'); num.className="form-control form-control-sm"; num.style.cssText="width:100%;height:20px;font-size:11px;text-align:center;padding:1px;"; num.step="0.1"; num.value=String(base);
  const rng=document.createElement("input"); rng.type="range"; rng.className="form-range"; rng.style.cssText="width:100%;height:12px;padding:0;margin:0 0 2px 0;"; rng.step="0.1"; rng.min=(base-5).toString(); rng.max=(base+5).toString(); rng.value=String(base);
  const listId="ticks-"+mono; rng.setAttribute("list", listId); const dl=document.createElement("datalist"); dl.id=listId; [rng.min,0,rng.max].forEach(v=>{const o=document.createElement("option"); o.value=v; dl.appendChild(o);});
  rng.addEventListener("input", ()=>{ num.value=rng.value; onUIChange(); });
  num.addEventListener("input", ()=>{ const v=parseNum(num.value); if(isFinite(v)){ rng.min=(v-5).toFixed(1); rng.max=(v+5).toFixed(1); rng.value=String(v); dl.innerHTML=""; [rng.min,0,rng.max].forEach(val=>{const o=document.createElement("option"); o.value=val; dl.appendChild(o);}); onUIChange(); }});
  wrap.append(lab,num,rng,dl);
  const idx=monomials.indexOf(mono); inputs[idx]=num; sliders[idx]=rng; return wrap;
}
function buildSliders(){
  const container=document.getElementById("sliderContainer"); container.innerHTML="";
  rows.forEach(rowList=>{
    const row=document.createElement("div"); row.style.cssText="display:flex;flex-wrap:wrap;justify-content:flex-start;gap:4px;margin-bottom:6px;padding-bottom:8px;";
    rowList.forEach(m=>row.appendChild(createSlider(m))); container.appendChild(row);
  });
}
function currentCoeffs(){ return monomials.map((m,i)=>{ const v=parseNum(inputs[i]?.value); return isFinite(v)?v:0; }); }
function updateFormula(){
  const coeffs=currentCoeffs(); const box = document.getElementById("formulaBox");
  const tex = buildFormulaTeXWrapped(coeffs, termsPerLineForWidth(box.clientWidth));
  const out = document.getElementById("formulaText");
  katex.render(tex, out, { displayMode:true, throwOnError:false });
}
function resetSlidersToCenter(span=5){
  for(let i=0;i<monomials.length;i++){
    const v=parseNum(inputs[i].value)||0; sliders[i].min=(v-span).toFixed(1); sliders[i].max=(v+span).toFixed(1); sliders[i].value=String(v);
    const listId="ticks-"+monomials[i]; const dl=sliders[i].list || document.getElementById(listId);
    if(dl){ dl.innerHTML=""; [sliders[i].min,0,sliders[i].max].forEach(val=>{const o=document.createElement("option"); o.value=val; dl.appendChild(o);}); }
  }
}
function applyPreset(key){
  const coeffs=PRESETS[key]; if(!Array.isArray(coeffs)) return;
  for(let i=0;i<monomials.length;i++) inputs[i].value=String(Number(coeffs[i]??0));
  resetSlidersToCenter(5); onUIChange();
}

/* =========================
   2) Renderer (sehr kompakt)
   ========================= */
class Renderer {
  constructor(canvas){ this.canvas=canvas; this.gl = canvas.getContext('webgl2'); this.state={ coeffs:new Float32Array(20), viewMode:1, showBox:true }; this.initGL(); this.start(); }
  initGL(){
    const gl=this.gl;
    // TODO: ersetze VS/FS durch deine Shader
    const vsSrc = `#version 300 es
    layout(location=0) in vec3 aPos;
    out vec3 vPos;
    uniform mat4 uMVP;
    void main(){ vPos=aPos; gl_Position = uMVP * vec4(aPos,1.0); }`;
    const fsSrc = `#version 300 es
    precision highp float;
    in vec3 vPos;
    out vec4 fragColor;
    // TODO: alle benötigten Uniforms
    uniform float uCoeffs[20];
    uniform int uViewMode;
    uniform bool uShowBox;
    // TODO: deine Raycasting-Funktion einfügen (Strahl aufbauen, g(t)=0 lösen, gradF, Shading)
    void main(){
      // Platzhalter-Farbe, damit es sofort etwas zeigt:
      fragColor = vec4(0.1,0.1,0.12,1.0);
    }`;
    const prog=this.prog=this.createProgram(vsSrc,fsSrc);
    gl.useProgram(prog);

    // Simple Proxy-Quad oder Box erstellen (hier: Fullscreen-Quad über TRIStrip)
    this.vao = gl.createVertexArray(); gl.bindVertexArray(this.vao);
    const quad=new Float32Array([-1,-1,0,  1,-1,0,  -1,1,0,  1,1,0]);
    const vbo=gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER,vbo); gl.bufferData(gl.ARRAY_BUFFER,quad,gl.STATIC_DRAW);
    gl.enableVertexAttribArray(0); gl.vertexAttribPointer(0,3,gl.FLOAT,false,0,0);

    // Uniform-Locations cachen
    this.u = {
      uMVP: gl.getUniformLocation(prog,"uMVP"),
      uCoeffs: Array.from({length:20},(_,i)=>gl.getUniformLocation(prog,`uCoeffs[${i}]`)),
      uViewMode: gl.getUniformLocation(prog,"uViewMode"),
      uShowBox: gl.getUniformLocation(prog,"uShowBox"),
    };
    // Simple MVP = Identity (Screen-Space Quad)
    gl.uniformMatrix4fv(this.u.uMVP,false,new Float32Array([1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1]));
    this.resize();
    window.addEventListener('resize',()=>this.resize());
  }
  createProgram(vs,fs){
    const gl=this.gl;
    const v=this.compile(gl.VERTEX_SHADER,vs);
    const f=this.compile(gl.FRAGMENT_SHADER,fs);
    const p=gl.createProgram(); gl.attachShader(p,v); gl.attachShader(p,f); gl.linkProgram(p);
    if(!gl.getProgramParameter(p,gl.LINK_STATUS)) throw new Error(gl.getProgramInfoLog(p));
    gl.deleteShader(v); gl.deleteShader(f); return p;
  }
  compile(type,src){
    const gl=this.gl, s=gl.createShader(type); gl.shaderSource(s,src); gl.compileShader(s);
    if(!gl.getShaderParameter(s,gl.COMPILE_STATUS)) throw new Error(gl.getShaderInfoLog(s)); return s;
  }
  resize(){
    const gl=this.gl, c=this.canvas;
    const dpr=Math.min(window.devicePixelRatio||1,2);
    const w=c.clientWidth|0, h=c.clientHeight|0;
    if(c.width!==w*dpr || c.height!==h*dpr){ c.width=w*dpr; c.height=h*dpr; }
    gl.viewport(0,0,c.width,c.height);
  }
  update({coeffs, viewMode, showBox}){
    // State speichern + Uniforms setzen
    if(coeffs){ this.state.coeffs.set(coeffs); }
    if(viewMode!=null) this.state.viewMode=viewMode;
    if(showBox!=null) this.state.showBox=!!showBox;

    const gl=this.gl; gl.useProgram(this.prog);
    for(let i=0;i<20;i++) gl.uniform1f(this.u.uCoeffs[i], this.state.coeffs[i]||0);
    gl.uniform1i(this.u.uViewMode, this.state.viewMode|0);
    gl.uniform1i(this.u.uShowBox, this.state.showBox?1:0);
  }
  start(){
    const gl=this.gl;
    const loop=()=>{
      gl.clearColor(0.97,0.98,1.0,1.0);
      gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);
      gl.useProgram(this.prog);
      gl.bindVertexArray(this.vao);
      gl.drawArrays(gl.TRIANGLE_STRIP,0,4);
      requestAnimationFrame(loop);
    };
    loop();
  }
}

/* =========================
   3) Verkabelung UI <-> Renderer
   ========================= */
let renderer;
function onUIChange(){
  const coeffs = new Float32Array(currentCoeffs());
  const viewMode = parseInt(document.getElementById("viewMode").value, 10);
  const showBox = document.getElementById("showBox").checked;
  renderer.update({ coeffs, viewMode, showBox });
  updateFormula();
}
function initApp(){
  buildSliders();
  applyPreset(document.getElementById("surfaceMode").value);
  updateFormula();

  document.getElementById("viewMode").addEventListener("change", onUIChange);
  document.getElementById("surfaceMode").addEventListener("change", (e)=>{ applyPreset(e.target.value); });
  document.getElementById("showBox").addEventListener("change", onUIChange);

  renderer = new Renderer(document.getElementById("glCanvas"));
  onUIChange();
}

(function waitForKatex(){
  if (window.katex && typeof katex.render === "function") initApp();
  else setTimeout(waitForKatex, 50);
})();
</script>
</body>
</html>
